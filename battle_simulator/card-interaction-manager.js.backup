/**
 * カードインタラクション管理システム
 * カードクリック時の動作を統一管理
 */

class CardInteractionManager {
  constructor(battleEngine) {
    this.battleEngine = battleEngine;
    this.currentActionMarks = null;
    this.initializeCardInteractions();
  }

  /**
   * カードインタラクションの初期化
   */
  initializeCardInteractions() {
    // battle engineにshowCardModal関数を追加
    this.battleEngine.showCardModal = (card, position = null) => {
      this.showCardInfo(card, position);
    };
  }

  /**
   * カード情報を右側パネルに表示し、アクションマークをカード上に表示
   * @param {Object} card - カードオブジェクト
   * @param {string} position - カードの位置（hand, center, collab等）
   */
  showCardInfo(card, position = null) {
    console.log('🃏 カードクリック:', card.name, 'Position:', position, 'Card ID:', card.id);
    
    // 右側パネルにカード詳細を表示
    this.showCardDetailInPanel(card);
    
    // カード上にアクションマークを表示
    this.showActionMarksOnCard(card, position);
  }

  /**
   * 右側パネルにカード詳細を表示
   * @param {Object} card - カードオブジェクト
   */
  showCardDetailInPanel(card) {
    // InfoPanelManagerを使用してカード詳細を表示
    if (this.battleEngine.infoPanelManager) {
      const cardDetailHtml = this.formatCardDetailForPanel(card);
      this.battleEngine.infoPanelManager.cardDetailElement.innerHTML = cardDetailHtml;
    }
  }

  /**
   * パネル用のカード詳細HTMLをフォーマット
   * @param {Object} card - カードオブジェクト
   */
  formatCardDetailForPanel(card) {
    let html = `
      <h3>📋 カード詳細</h3>
      <div class="card-name">${card.name || 'Unknown'}</div>
    `;

    if (card.card_type) {
      html += `<div class="card-type">種類: ${card.card_type}</div>`;
    }

    if (card.card_color) {
      html += `<div class="card-color">色: ${card.card_color}</div>`;
    }

    if (card.bloom_level) {
      html += `<div class="card-bloom">ブルーム: ${card.bloom_level}</div>`;
    }

    if (card.hp) {
      html += `<div class="card-hp">HP: ${card.hp}</div>`;
    }

    if (card.rarity) {
      html += `<div class="card-rarity">レアリティ: ${card.rarity}</div>`;
    }

    if (card.skills && card.skills.length > 0) {
      html += `<div class="card-skills"><strong>🎯 スキル:</strong><br>`;
      card.skills.forEach(skill => {
        const skillText = skill.text || skill.name || skill.description || 'スキル詳細なし';
        html += `<div class="skill-item">• ${skillText}</div>`;
      });
      html += `</div>`;
    }

    if (card.skill_description) {
      html += `<div class="card-description"><strong>📝 効果:</strong><br>${card.skill_description}</div>`;
    }

    return html;
  }

  /**
   * カード上にアクションマークを表示
   * @param {Object} card - カードオブジェクト
   * @param {string} position - カードの位置
   */
  showActionMarksOnCard(card, position) {
    // 既存のアクションマークを削除
    this.clearActionMarks();

    const cardElement = this.findCardElement(card.id);
    console.log('🎯 カード要素検索:', card.id, cardElement ? '見つかった' : '見つからない');
    
    if (!cardElement) return;

    const availableActions = this.getAvailableActions(card, position);
    // 効果発動のみを対象とし、発動可能な場合のみ表示
    const actionableActions = availableActions.filter(action => 
      action.type === 'effect' && !action.disabled
    );

    console.log('⚡ 効果発動可能:', actionableActions.length > 0);

    if (actionableActions.length === 0) return;

    // アクションマークコンテナを作成
    const actionContainer = document.createElement('div');
    actionContainer.className = 'card-action-marks';
    actionContainer.style.cssText = `
      position: absolute;
      top: 5px;
      right: 5px;
      display: flex;
      gap: 3px;
      z-index: 10;
      pointer-events: none;
    `;

    actionableActions.forEach(action => {
      const actionMark = document.createElement('div');
      actionMark.className = `action-mark action-${action.type}`;
      actionMark.style.cssText = `
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        cursor: pointer;
        pointer-events: auto;
        transition: transform 0.2s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      `;

      // アクションタイプに応じたアイコン
      switch (action.type) {
        case 'effect':
          actionMark.textContent = '💥';
          actionMark.title = '効果を発動';
          break;
        case 'bloom':
          actionMark.textContent = '🌸';
          actionMark.title = 'ブルームする';
          break;
        case 'play':
          actionMark.textContent = '▶️';
          actionMark.title = 'カードをプレイ';
          break;
        case 'move':
          actionMark.textContent = '🔄';
          actionMark.title = 'カードを移動';
          break;
        case 'baton':
          actionMark.textContent = '🏃';
          actionMark.title = 'バトンタッチ';
          break;
        default:
          actionMark.textContent = '⚡';
          break;
      }

      // ホバー効果
      actionMark.addEventListener('mouseenter', () => {
        actionMark.style.transform = 'scale(1.2)';
      });

      actionMark.addEventListener('mouseleave', () => {
        actionMark.style.transform = 'scale(1)';
      });

      // クリックイベント
      actionMark.addEventListener('click', (e) => {
        e.stopPropagation();
        this.executeAction(action.id, card.id, position);
      });

      actionContainer.appendChild(actionMark);
    });

    // カード要素に相対位置を設定
    if (cardElement.style.position !== 'relative' && cardElement.style.position !== 'absolute') {
      cardElement.style.position = 'relative';
    }

    cardElement.appendChild(actionContainer);
    this.currentActionMarks = actionContainer;
  }

  /**
   * アクションマークをクリア
   */
  clearActionMarks() {
    if (this.currentActionMarks) {
      this.currentActionMarks.remove();
      this.currentActionMarks = null;
    }
    
    // 全てのアクションマークを削除（念のため）
    document.querySelectorAll('.card-action-marks').forEach(mark => {
      mark.remove();
    });
  }

  /**
   * カード要素を検索
   * @param {string} cardId - カードID
   */
  findCardElement(cardId) {
    // data-card-id属性でカード要素を検索
    const elements = document.querySelectorAll(`[data-card-id="${cardId}"]`);
    
    // 複数見つかった場合は最初のものを返す
    // （同じカードが複数枚ある場合を考慮）
    return elements.length > 0 ? elements[0] : null;
  }

  /**
   * アクションを実行（効果発動のみ）
   * @param {string} actionId - アクションID
   * @param {string} cardId - カードID
   * @param {string} position - カードの位置
   */
  async executeAction(actionId, cardId, position) {
    const card = this.findCard(cardId);
    if (!card) {
      console.error('カードが見つかりません:', cardId);
      return;
    }

    try {
      if (actionId === 'activate_effect') {
        await this.activateCardEffect(card, position);
      } else {
        console.warn('サポートされていないアクション:', actionId);
      }
    } catch (error) {
      console.error('アクション実行エラー:', error);
      this.showMessage('アクションの実行中にエラーが発生しました', 'error');
    }
  }

  /**
   * 利用可能なアクションを取得（効果発動のみに簡素化）
   * @param {Object} card - カードオブジェクト
   * @param {string} position - カードの位置
   */
  getAvailableActions(card, position) {
    const actions = [];
    const currentPlayer = this.battleEngine.gameState.currentPlayer;
    const isPlayerCard = this.isPlayerCard(card, position);

    // 詳細表示（常に利用可能）
    actions.push({
      id: 'view_details',
      label: '詳細を見る',
      type: 'info',
      disabled: false
    });

    // プレイヤーのカードで効果発動可能な場合のみ
    if (isPlayerCard && this.hasManualEffect(card)) {
      const canActivate = this.canActivateEffect(card, position);
      if (canActivate) {
        actions.push({
          id: 'activate_effect',
          label: '効果を発動',
          type: 'effect',
          disabled: false
        });
      }
    }

    return actions;
  }

  /**
   * カード効果の手動発動
   */
  async activateCardEffect(card, position) {
    if (!this.battleEngine.cardEffectTriggerSystem) {
      this.showMessage('カード効果システムが初期化されていません', 'error');
      return;
    }

    const currentPlayer = this.battleEngine.gameState.currentPlayer;
    
    try {
      const result = await this.battleEngine.cardEffectTriggerSystem.manualTrigger(card.id, currentPlayer);
      
      if (result && result.length > 0) {
        const successResults = result.filter(r => r.success);
        if (successResults.length > 0) {
          this.showMessage('カード効果を発動しました', 'success');
          this.clearActionMarks();
        } else {
          this.showMessage('カード効果を発動できませんでした', 'error');
        }
      } else {
        this.showMessage('発動可能な効果がありません', 'error');
      }
    } catch (error) {
      console.error('効果発動エラー:', error);
      this.showMessage('効果の発動中にエラーが発生しました', 'error');
    }
  }

  /**
   * ヘルパーメソッド群
   */
  isPlayerCard(card, position) {
    const currentPlayer = this.battleEngine.gameState.currentPlayer;
    return currentPlayer === 1; // プレイヤー1のカードかどうか
  }  /**
   * カード効果の手動発動
   */
  async activateCardEffect(card, position) {
    if (!this.battleEngine.cardEffectTriggerSystem) {
      this.showMessage('カード効果システムが初期化されていません', 'error');
      return;
    }

    const currentPlayer = this.battleEngine.gameState.currentPlayer;
    
    try {
      const result = await this.battleEngine.cardEffectTriggerSystem.manualTrigger(card.id, currentPlayer);
      
      if (result && result.length > 0) {
        const successResults = result.filter(r => r.success);
        if (successResults.length > 0) {
          // 効果使用済みマークを設定
          this.markEffectAsUsed(card, position);
          
          this.showMessage('カード効果を発動しました', 'success');
          this.clearActionMarks();
        } else {
          this.showMessage('カード効果を発動できませんでした', 'error');
        }
      } else {
        this.showMessage('発動可能な効果がありません', 'error');
      }
    } catch (error) {
      console.error('効果発動エラー:', error);
      this.showMessage('効果の発動中にエラーが発生しました', 'error');
    }
  }

  /**
   * 効果使用済みマークを設定
   */
  markEffectAsUsed(card, position) {
    const cardEffect = window.cardEffects[card.id];
    if (!cardEffect) return;

    for (const trigger of cardEffect.triggers) {
      switch (trigger.timing) {
        case 'on_bloom':
          card.bloomEffectUsed = true;
          break;
        case 'on_collab':
          card.collabEffectUsed = true;
          break;
        // ギフトは常時効果なので使用済みマークなし
        // アーツは未実装
        // 推しホロメンは未実装
      }
    }
  }

  /**
   * カード移動の開始
   */
  async initiateMoveCard(card, position) {
    this.showMessage('移動先をクリックしてください', 'info');
    this.clearActionMarks();
    // ドラッグ&ドロップモードを有効化
    // 実際の移動処理は既存のドラッグ&ドロップシステムを使用
  }

  /**
   * ブルームの開始
   */
  async initiateBloom(card, position) {
    this.showMessage('ブルーム先のカードを選択してください', 'info');
    this.clearActionMarks();
    // ブルーム処理を開始
  }

  /**
   * バトンタッチの開始
   */
  async initiateBatonTouch(card) {
    this.showMessage('バトンタッチ先のホロメンを選択してください', 'info');
    this.clearActionMarks();
    // バトンタッチ処理を開始
  }

  /**
   * ヘルパーメソッド群
   */
  isPlayerCard(card, position) {
    const currentPlayer = this.battleEngine.gameState.currentPlayer;
    return currentPlayer === 1; // プレイヤー1のカードかどうか
  }

  hasManualEffect(card) {
    // カードに手動発動可能な効果があるかチェック
    if (!window.cardEffects || !window.cardEffects[card.id]) {
      return false;
    }
    
    const cardEffect = window.cardEffects[card.id];
    
    // 古い形式のトリガーシステム
    if (cardEffect.triggers && cardEffect.triggers.some(t => t.timing === 'manual_trigger')) {
      return true;
    }
    
    // 新しい形式のコラボエフェクト
    if (cardEffect.collabEffect) {
      return true;
    }
    
    // ブルームエフェクトも手動発動可能
    if (cardEffect.bloomEffect) {
      return true;
    }
    
    return false;
  }

  /**
   * 効果発動可能かチェック（正しいタイミング判定）
   * @param {Object} card - カードオブジェクト
   * @param {string} position - カードの位置
   */
  canActivateEffect(card, position) {
    const currentPhase = this.battleEngine.gameState.currentPhase;
    const gameState = this.battleEngine.gameState;
    
    if (!this.hasManualEffect(card)) {
      return false;
    }

    const cardEffect = window.cardEffects[card.id];
    if (!cardEffect) return false;

    // 新しい形式のコラボエフェクト
    if (cardEffect.collabEffect && position === 'collab') {
      return this.canActivateCollabEffect(card, position);
    }
    
    // 新しい形式のブルームエフェクト
    if (cardEffect.bloomEffect) {
      return this.canActivateBloomEffect(card, position);
    }

    // 古い形式のトリガーシステム（後方互換性）
    if (cardEffect.triggers) {
      for (const trigger of cardEffect.triggers) {
        switch (trigger.timing) {
          case 'on_bloom':
            // ブルームエフェクト：ブルームしたターンのみ発動可能
            return this.canActivateBloomEffect(card, position);
            
          case 'on_collab':
            // コラボエフェクト：コラボしたターンのみ発動可能
            return this.canActivateCollabEffect(card, position);
            
          case 'gift':
            // ギフト：場にいる間は常に発揮（手札からは不可）
            return this.canActivateGiftEffect(card, position);
            
          case 'arts':
          // アーツ：パフォーマンスステップのみ（未実装）
          return false;
          
        case 'oshi_holomen':
          // 推しホロメン：専用実装（未実装）
          return false;
          
        case 'manual_trigger':
          // 汎用手動トリガー（従来の実装）
          return currentPhase === 3; // メインフェーズのみ
      }
    }
    
    return false;
  }

  /**
   * ブルームエフェクト発動可能かチェック
   */
  canActivateBloomEffect(card, position) {
    // 場にいるカードのみ
    if (position === 'hand') return false;
    
    // ブルームしたターンかチェック
    const gameState = this.battleEngine.gameState;
    const currentTurn = gameState.turnCount;
    
    // カードにブルームしたターンの情報があるかチェック
    if (card.bloomedTurn && card.bloomedTurn === currentTurn) {
      // まだ効果を使用していないかチェック
      return !card.bloomEffectUsed;
    }
    
    return false;
  }

  /**
   * コラボエフェクト発動可能かチェック
   */
  canActivateCollabEffect(card, position) {
    // コラボエリアにいるカードのみ
    if (position !== 'collab') {
      console.log('🚫 コラボエフェクト: コラボエリアにいない', position);
      return false;
    }
    
    // コラボしたターンかチェック
    const gameState = this.battleEngine.gameState;
    const stateManagerTurn = this.battleEngine.stateManager.getStateByPath('turn.turnCount');
    const currentTurn = gameState.turnCount;
    
    console.log('🔍 詳細コラボエフェクトチェック:');
    console.log('  - gameState.turnCount:', currentTurn);
    console.log('  - stateManager.turn.turnCount:', stateManagerTurn);
    console.log('  - card.collabedTurn:', card.collabedTurn);
    console.log('  - card.collabEffectUsed:', card.collabEffectUsed);
    console.log('  - card.name:', card.name);
    console.log('  - card.id:', card.id);
    
    // カードにコラボしたターンの情報があるかチェック
    if (card.collabedTurn && card.collabedTurn === currentTurn) {
      // まだ効果を使用していないかチェック
      const canActivate = !card.collabEffectUsed;
      console.log('✅ コラボエフェクト発動可能:', canActivate);
      return canActivate;
    }
    
    console.log('🚫 コラボエフェクト: ターンが一致しない or collabedTurnが未設定');
    return false;
  }

  /**
   * ギフト効果発動可能かチェック
   */
  canActivateGiftEffect(card, position) {
    // 手札からは発動不可
    if (position === 'hand') return false;
    
    // 場にいる間は常に発動可能
    const fieldPositions = ['center', 'collab', 'back1', 'back2', 'back3', 'back4', 'back5'];
    return fieldPositions.includes(position);
  }

  findCard(cardId) {
    const currentPlayer = this.battleEngine.gameState.currentPlayer;
    const player = this.battleEngine.players[currentPlayer];
    
    // 全エリアからカードを検索
    const areas = ['center', 'collab', 'back1', 'back2', 'back3', 'back4', 'back5', 'hand', 'archive'];
    
    for (const area of areas) {
      if (Array.isArray(player[area])) {
        const card = player[area].find(c => c && c.id === cardId);
        if (card) return card;
      } else if (player[area] && player[area].id === cardId) {
        return player[area];
      }
    }
    
    return null;
  }

  /**
   * メッセージ表示メソッド
   */
  showMessage(message, type = 'info') {
    const messageHtml = `
      <div class="card-action-message ${type}" id="card-action-message">
        <div class="message-content">
          ${message}
        </div>
      </div>
    `;

    // 既存のメッセージを削除
    const existingMsg = document.getElementById('card-action-message');
    if (existingMsg) {
      existingMsg.remove();
    }

    document.body.insertAdjacentHTML('beforeend', messageHtml);
    
    // 3秒後に自動で消去
    setTimeout(() => {
      const msgElement = document.getElementById('card-action-message');
      if (msgElement) {
        msgElement.remove();
      }
    }, 3000);
  }
}

// グローバルエクスポート
if (typeof window !== 'undefined') {
  window.CardInteractionManager = CardInteractionManager;
}
