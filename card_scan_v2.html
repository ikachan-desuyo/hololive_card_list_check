<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ホロライブカード枠検出</title>
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();"></script>
  <style>
    video, canvas {
      display: block;
      margin: 10px auto;
      border: 1px solid black;
    }
    button {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <h1>ホロライブカード枠検出</h1>
  <div id="status" style="text-align: center; font-weight: bold;">OpenCV.jsを読み込み中...</div>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvasOutput"></canvas>
  <canvas id="canvasEdges" style="display: none;"></canvas>
  <canvas id="canvasCropped" style="display: none;"></canvas>
  <button id="detect-button">カード枠を検出</button>
  <button id="toggle-button">切り替え: 元映像</button>
  <button id="crop-toggle-button">切り替え: トリミング結果</button>

  <script>
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvasOutput');
    let canvasEdges = document.getElementById('canvasEdges');
    let canvasCropped = document.getElementById('canvasCropped');
    let ctx = canvas.getContext('2d');
    let ctxEdges = canvasEdges.getContext('2d');
    let ctxCropped = canvasCropped.getContext('2d');
    let streaming = false;
    let showEdges = false;
    let showCropped = false;

    function onOpenCvReady() {
      document.getElementById('status').innerText = "OpenCV.js 読み込み完了！";
      startCamera();
    }

    function startCamera() {
      navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
        .then(stream => {
          video.srcObject = stream;
          video.play();
          video.addEventListener('loadedmetadata', () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvasEdges.width = video.videoWidth;
            canvasEdges.height = video.videoHeight;
            canvasCropped.width = video.videoWidth;
            canvasCropped.height = video.videoHeight;
            streaming = true;
          });
        })
        .catch(err => {
          console.error("カメラの起動に失敗しました:", err);
          alert("カメラの起動に失敗しました。デバイスのカメラ権限を確認してください。");
        });
    }

    document.getElementById('detect-button').addEventListener('click', () => {
      if (!streaming) return;
      detectCardFrames();
    });

    document.getElementById('toggle-button').addEventListener('click', () => {
      showEdges = !showEdges;
      if (showEdges) {
        canvas.style.display = 'none';
        canvasEdges.style.display = 'block';
        canvasCropped.style.display = 'none';
        document.getElementById('toggle-button').innerText = '切り替え: エッジ映像';
      } else {
        canvas.style.display = 'block';
        canvasEdges.style.display = 'none';
        document.getElementById('toggle-button').innerText = '切り替え: 元映像';
      }
    });

    document.getElementById('crop-toggle-button').addEventListener('click', () => {
      showCropped = !showCropped;
      if (showCropped) {
        canvas.style.display = 'none';
        canvasEdges.style.display = 'none';
        canvasCropped.style.display = 'block';
        document.getElementById('crop-toggle-button').innerText = '切り替え: トリミング結果';
      } else {
        canvasCropped.style.display = 'none';
        document.getElementById('crop-toggle-button').innerText = '切り替え: 元映像';
      }
    });

    function detectCardFrames() {
      // ビデオフレームをキャンバスに描画
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      let src = cv.imread(canvas);

      // グレースケール変換
      let gray = new cv.Mat();
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

      // エッジ検出 (Canny)
      let edges = new cv.Mat();
      cv.Canny(gray, edges, 50, 150);

      // エッジ映像を描画
      let edgeCanvasMat = new cv.Mat();
      cv.cvtColor(edges, edgeCanvasMat, cv.COLOR_GRAY2RGBA);
      cv.imshow('canvasEdges', edgeCanvasMat);

      // 輪郭検出で四角形を特定
      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      const CARD_RATIO = 88 / 63; // 縦横比
      const MIN_AREA = canvas.width * canvas.height * 0.01; // 最小面積 (画面の1%)
      const frameCenterX = canvas.width / 2;
      const frameCenterY = canvas.height / 2;
      let bestRect = null;
      let bestScore = -1;

      for (let i = 0; i < contours.size(); i++) {
        let contour = contours.get(i);

        // 輪郭を近似
        let approx = new cv.Mat();
        cv.approxPolyDP(contour, approx, 0.02 * cv.arcLength(contour, true), true);

        // 四角形かつ縦横比がカードに近いものを選択
        if (approx.rows === 4) {
          let rect = cv.boundingRect(approx);
          let area = rect.width * rect.height;

          // 最小面積フィルタ
          if (area >= MIN_AREA) {
            // 中心位置を計算
            let centerX = rect.x + rect.width / 2;
            let centerY = rect.y + rect.height / 2;
            let distanceToCenter = Math.sqrt(
              Math.pow(centerX - frameCenterX, 2) + Math.pow(centerY - frameCenterY, 2)
            );

            // 縦横比を厳密にチェック (±5%の許容範囲)
            let aspectRatio = rect.height / rect.width;
            if (0.95 * CARD_RATIO < aspectRatio && aspectRatio < 1.05 * CARD_RATIO) {
              // スコア計算: 面積と中心からの距離を考慮
              let normalizedDistance = distanceToCenter / Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height);
              let normalizedArea = area / (canvas.width * canvas.height);
              let score = normalizedArea * (1 - normalizedDistance); // 面積が大きく、中心に近いほど高スコア

              if (score > bestScore) {
                bestRect = rect;
                bestScore = score;
              }
            }
          }
        }
        approx.delete();
      }

      if (bestRect) {
        // トリミング処理
        let cropped = src.roi(bestRect);
        cv.imshow('canvasCropped', cropped);
        cropped.delete();
      }

      // 検出結果をキャンバスに表示
      cv.imshow('canvasOutput', src);

      // リソース解放 - より体系的なクリーンアップ
      src.delete();
      gray.delete();
      edges.delete();
      edgeCanvasMat.delete();
      contours.delete();
      hierarchy.delete();
    }
  </script>
</body>
</html>